[{"date":"2018-09-27","link":"https://en.wikipedia.org/wiki/Booting","text":"Booting is starting up a computer or computer appliance until it can be used.\n\nThe computer first executes a relatively small program stored in read-only memory (ROM) along with a small amount of needed data, to access the nonvolatile device or devices from which the operating system programs and data can be loaded into RAM.\n\nThe small program that starts this sequence is known as a bootstrap loader, bootstrap or boot loader. This small program's only job is to load other data and programs which are then executed from RAM.\n\n","title":"Booting"},{"date":"2018-09-27","link":"https://en.wikipedia.org/wiki/Routing_table","text":"In computer networking a routing table, or routing information base (RIB), is a data table stored in a router or a networked computer that lists the routes to particular network destinations, and in some cases, metrics (distances) associated with those routes.\n\nREAD LINK","title":"Routing Table"},{"date":"2018-09-27","link":"","text":"Kindle\n---------------------\n|039|095|129|000|000|\n---------------------\n|   | x |   |   |   |\n---------------------\n\nScheduling: FIFO, Shortest Job First, Shortest Time-To-Completion, Round Robin, Multi-level Feedback Queue.","title":"Operating Systems Tree Easy Pieces"},{"date":"2018-09-27","link":"http://dewassoc.com/kbase/hard_drives/master_boot_record.htm","text":"When you turn on your PC, the processor attempts to begin the process of processing data. But, since the system memory is empty, the processor doesn't really have anything to execute. To ensure that the PC will always boot regardless of the BIOS code, both chip and BIOS manufacturers developed their code so that the processor, once turned on, always starts executing at the same place, FFFF0h.\n\nSimilarly, every hard disk must have a consistent \"starting point\" where key information is stored about the disk. There also must be someplace where the BIOS can load the initial boot program that starts the process of loading the operating system. The place where this information is stored is called the master boot record (MBR).\n\nThe master boot record is always located at cylinder 0, head 0, and sector 1, the first sector on the disk. This is the consistent starting point that the disk will always use. \nWhen a computer starts and the BIOS boots the machine, it will always look at this first sector for instructions and information on how to proceed with the boot process and load the operating system.\n\nThe master boot record contains the following structures:\n\t* Master Partition Table: table that contains a complete description of the partitions that are contained on the hard disk.\n\t* Master Boot Code: code that the BIOS loads and executes to start the boot process. This code, when fully executed, transfers control to the boot program stored on the boot (active) partition to load the operating system.\n\nWhat occurs during the System Boot Sequence?\n\t1. The internal power supply turns on, initializes and then takes a few moments to generate reliable power for the rest of the computer. If the power received by the motherboard's chipset, and subsequently the processor, is not within expected parameters, the chipset will generate a reset signal to the processor in the same fashion as if you were to touch the reset button. This will continue until the motherboard receives a Power Good signal from the power supply or you turn the system off because of a failed power supply.\n\t\n\t2. After a Power Good signal is received, the processor will be ready to start executing. When the processor first starts, it really has no idea what to do next as there is nothing at all in the memory to execute. Of course the processor designers are aware of this, so they pre-program the processor to always look at the same place in the system, the BIOS ROM, for the small bit of startup code to begin the boot process. This is typically located at memory location FFFF0h. Since there are only 16 bytes from there to the end of conventional memory area, this location contains just a \"jump\" instruction telling the processor where to go to find the real BIOS startup program.\n\t\n\t3. The BIOS performs the power-on self test (POST). If there are any fatal errors, the boot process stops. If the POST is successful, the BIOS calls INT 19 and then proceeds to look for devices attached to the motherboard.\n\t\n\t4. The BIOS code begins its search by looking for a video card. The system BIOS executes the video card BIOS, which in turn initializes the video card. Most modern video cards will display information on the screen about the video card.\n\t\n\t5. Once video has been enabled, the BIOS begins searching for other devices that may have their own ROM and whether that ROM has its own BIOS code. Normally, the floppy drive is located at 0000:7C00, and the IDE/ATA hard disk BIOS will be found at C8000h. If a floppy and/or hard drive is found, their codes are executed. If, during this INT 19 process, any other device BIOS's are found, they are executed as well.\n\t\n\t6. The BIOS displays its startup screen, which provides some key information about the BIOS as well as other system information.\n\t\n\t7. As the boot sequence continues, the BIOS continues to perform additional tests on the system. Depending upon the system manufacturer, this will usually include a memory count. The BIOS will generally display an error message on the screen if it encounters an error when it counts installed memory.\n\t\n\t8. Performs somewhat of an inventory of the hardware installed in the system, and then communicates or interrogates it to ensure that the hardware is functioning. Most modern BIOS's have automatic settings to collect information such as memory timing, based on what kind of memory it finds. Today's BIOS's dynamically set hard drive parameters and access modes, and will display a message on the screen for each drive they detect and configure in this way. It will also search for and label logical devices such as COM and LPT ports. Note: If the BIOS supports the Plug and Play standard, and the feature is enabled, this is the point at which it will detect and configure Plug and Play devices and display a message on the screen for each one found.\n\t\n\t9. During the final phase of the POST and BIOS boot process, the BIOS will display a summary screen with your system's configuration. Checking this data can be helpful in diagnosing setup problems, although it can be hard to see because sometimes it flashes on the screen and then scrolls off the top.\n\t\n\t10. Once the BIOS finishes what it needs to do, it begins searching for a drive to boot an operating system. All BIOS's contain a setting that controls this search sequence for a boot drive. Most are set to first look for a bootable floppy disk, and if one is not found then proceed to a hard disk, which is usually the C: drive. Once the BIOS identifies its target boot drive, the it looks for boot information to start the operating system boot process. If it is searching a hard disk, it looks for a master boot record at cylinder 0, head 0, sector 1, the first sector on the disk.\n\t\n\t11. Once the boot sector is found and its contents or data verified, the BIOS starts the process of booting the operating system by using the information in the boot sector. If this is a floppy disk boot sector, the information is read into memory at location 0000:7c00. INT 19 goes to memory location 0000:7c00 to continue the process. If no boot sector is found on the floppy drive, INT 19 moves to the next bootable drive in the list provided by the motherboard BIOS, usually a hard drive, and then attempts to read the MBR. If a Master Boot Record is found, it is read into memory at location 0000:7c00 and INT 19 jumps to memory location 0000:7c00 the same as was the case with the floppy. At this point, the BIOS attempts to move control of the computer from the BIOS to the actual operating system.\n\t\n\tNext, the small program in the Master Boot Record will attempt to locate an active (bootable) partition in the hard drives partition table. If such a partition is found, the boot sector of that partition is also read into memory at location 0000:7C00 and then MBR program itself jumps to memory location 0000:7C00. Keep in mind that each operating system has its own boot sector format. The next step involves the small program in the boot sector locating the first part of the operating system's kernel loader program, or in some cases the kernel itself or perhaps a boot manager program, and read then that into memory. For you Windows NT and Windows 2000 fans, this kernel loader is referred to as NTLDR. You will find a description of the DOS boot process here.\n\t\n\t13. If no boot device of any type can be found, the system will display an error message and stop. The specific error message is depends on the BIOS developer and/or the computer's manufacturer, and can be anything from a rather clear \"No boot device\" to the very cryptic \"NO ROM BASIC - SYSTEM HALTED\". This will also happen if you have a bootable hard disk partition but forget to set it active. Believe it or not, you can partition a drive, format it and install the operating system and never realize that there is problem until the first start of that operating system occurs.\n\t\n\tThis entire process is referred to as a \"cold boot\" (since the machine was off, or cold, when it started). A \"warm boot\" also known as a \"soft boot\" is the same thing except it occurs when the machine is rebooted using the Ctrl + Alt + Del keys. In this case the POST is skipped and the boot process continues at roughly step 8 above.","title":"Master Boot Record"},{"date":"2018-09-28","link":"https://docs.google.com/spreadsheets/d/1wijIFVnnrdvsv1_Kw6n1O_kqLEYYtPk-lEbFJfoI3fU/edit?usp=sharing","text":" ","title":"Computer Systems I"},{"date":"2018-09-28","link":"https://en.wikipedia.org/wiki/Granularity_(parallel_computing)","text":"Consider a 10*10 image that needs to be processed, given that, processing of the 100 pixels is independent of each other.\n\n\tFine-grained parallelism: Assume there are 100 processors that are responsible for processing the 10*10 image. Ignoring the communication overhead, the 100 processors can process the 10*10 image in 1 clock cycle. Each processor is working on 1 pixel of the image and then communicates the output to other processors. This is an example of fine-grained parallelism.\n\n\tMedium-grained parallelism: Consider that there are 25 processors processing the 10*10 image. The processing of the image will now take 4 clock cycles. This is an example of medium-grained parallelism.\n\n\tCoarse-grained parallelism: Further, if we reduce the processors to 2, then the processing will take 50 clock cycles. Each processor need to process 50 elements which increases the computation time, but the communication overhead decreases as the number of processors which share data decreases. This case illustrates coarse-grained parallelism. ","title":"Granularity"},{"date":"2018-09-28","link":"http://beyond-syntax.com/blog/2011/03/diving-into-linux-networking-i/","text":"Typically during the boot process the driver is loaded into the kernel as a kernel module. When the module is registered with the kernel it executes a callback function called igb_init_module. This function registers the driver with the PCI bus and provides another callback which is executed once the PCI bus is configured.\n\nThe driver actually enables the device on the PCI bus, gets memory for PCI device input/output, sets device specific callback functions (like open and close).\n\nTo send a packet to the network, the network card driver first writes the full packet to the memory, at an address aligned to a multiple of 4 bytes. It then writes to a couple of registers on the network interface card, telling it the memory address, the packet size, and some other information. The network card then reads the packet from the memory, sends it to the network, and signals the interrupt. The interrupt controller (a separate piece of hardware) sends the interrupt request to the CPU and tells it the interrupt number. In the interrupt handler, the driver reads a register from the card which tells it the interrupt was about a packet being sent, reads another register to find out which packet was sent, and knows it can now reuse the memory where it had written the packet.\n\nTo receive packets from the network, the network card driver allocates a block of memory to be used as storage for the packets, and writes several registers on the card telling it the memory address of the block of memory, its size, and some other information. When a packet is received from the network, the network card writes it to that block of memory, together with the packet's size and some other information. It updates some registers which tell both it and the driver how much free space is there in that block of memory, where the free space begins, and where the used space begins (the buffer is circular, so after getting to the end it rolls over to the beginning). Finally, it signals its interrupt. The driver will read the registers and the memory to obtain the packet(s), and will update the registers to tell the card that space is now free again.","title":"Linux Networking Stack"},{"date":"2018-09-28","link":"https://en.wikipedia.org/wiki/Central_processing_unit","text":"A central processing unit (CPU) is the electronic circuitry within a computer that carries out the instructions of a computer program by performing the basic arithmetic, logical, control and input/output (I/O) operations specified by the instructions.\n\nTo ensure proper operation of the CPU, the clock period is longer than the maximum time needed for all signals to propagate (move) through the CPU.\n\nSubscalar: operates on and executes one instruction on one or two pieces of data at a time, that is less than one instruction per clock cycle (IPC < 1).\n\nInstruction pipelining: begin the first steps of instruction fetching and decoding before the prior instruction finishes executing.\n\n","title":"Central Unit"},{"date":"2018-09-28","link":"https://en.wikipedia.org/wiki/BIOS","text":"The BIOS is non-volatile firmware used to perform hardware initialization during the booting process (power-on startup), and to provide runtime services for operating systems and programs. The BIOS firmware comes pre-installed on a personal computer's system board, and it is the first software to run when powered on.\n\nWhen the computer is turned on:\n- The CPU \"wakes up\" (has power) and reads the x86 code in the BIOS chip. The code in the BIOS chip runs a series of tests, called the POST for Power On Self Test, to make sure the system devices are working correctly.\n\nThe POST checks, identifies, and initializes system devices such as the CPU, RAM, interrupt and DMA controllers and other parts of the chipset, video display card, keyboard, hard disk drive, optical disc drive and other basic hardware.\n\nIn general, the BIOS:\nInitializes system hardware and chipset registers\nInitializes power management\nTests RAM\nEnables the keyboard\nTests serial and parallel ports\nInitializes floppy disk drives and hard disk drive controllers \nDisplays system summary information\n\nAfter the POST tasks are completed, the BIOS looks for the boot program responsible for loading the operating system. Usually, the BIOS looks on the floppy disk drive A: followed by drive C:\n\n","title":"BIOS"},{"date":"2018-09-28","link":"https://docs.google.com/spreadsheets/d/1wijIFVnnrdvsv1_Kw6n1O_kqLEYYtPk-lEbFJfoI3fU/edit#gid=0&range=A66:C66","text":"Strict Priorities: High/Low\nWeighted Priorities: 1/2/w\n\nMax-min fair allocation\n\nAIMD - Additive Increase, Multiplicative Decrease\n\nFull-cone NAT\n(Address)-restricted-cone NAT\nPort-restricted cone NAT\nSymmetric NAT","title":"Computer Networks III"},{"date":"2018-09-29","link":"","text":"PDF\n\nAre all the boundary conditions CORRECT?\nCan you force error conditions to happen?\nOnce you think of something that could go wrong, write a test for it\nIdentify the bug. Write a test that fails, to prove the bug exists. \nFix the code such that the test now passes. \nVerify that all tests still pass.","title":"Pragmatic Unit Testing"},{"date":"2018-09-29","link":"https://docs.google.com/spreadsheets/d/1wijIFVnnrdvsv1_Kw6n1O_kqLEYYtPk-lEbFJfoI3fU/edit?usp=sharing","text":"Direct Mapped Cache (E = 1)\nE-way Set Associative Cache\n\nWrite-through: write immediately to memory\nWrite-back: defer write to memory until replacement of line (*)\n\nWrite-allocate: load into cache, update line in cache (*)\nNo-write-allocate: writes straight to memory, does not load into cache","title":"Computer Systems  II"},{"date":"2018-09-29","link":"","text":"PDF\n\n- Don't be afraid to admit ignorance or error\n- Instead of excuses, provide options. Don't say it can't be done; explain what can be done to salvage the situation\n- What to Say When Asked for an Estimate? \"I'll get back to you.\"\n- The best way to start fixing a bug is to make it reproducible","title":"The Pragmatic Programmer"},{"date":"2018-09-29","link":"https://en.wikipedia.org/wiki/Interrupt_request_(PC_architecture)","text":"An interrupt request (or IRQ) is a hardware signal sent to the processor that temporarily stops a running program and allows a special program, an interrupt handler, to run instead. Hardware interrupts are used to handle events such as receiving data from a modem or network card, key presses, or mouse movements.","title":"IRQ"},{"date":"2018-09-29","link":"https://en.wikipedia.org/wiki/Out-of-order_execution","text":"OfOE is a paradigm used in most high-performance central processing units to make use of instruction cycles that would otherwise be wasted. In this paradigm, a processor executes instructions in an order governed by the availability of input data and execution units, rather than by their original order in a program.\n\n1- Instruction fetch.\n2- Instruction dispatch to an instruction queue (also called instruction buffer or reservation stations).\n3- The instruction waits in the queue until its input operands are available. The instruction is then allowed to leave the queue before earlier, older instructions.\n4- The instruction is issued to the appropriate functional unit and executed by that unit.\n5- The results are queued.\n6- Only after all older instructions have their results written back to the register file, then this result is written back to the register file. This is called the graduation or retire stage.","title":"Out-of-order execution"},{"date":"2018-09-29","link":"","text":"Process Control Block is a data structure in the operating system kernel containing the information needed to manage the scheduling of a particular process.\n\nProcess control information is used by the OS to manage the process itself. This includes:\n    *The process scheduling state: name, priority value, the amount of time elapsed since the process gained control of the CPU or since it was suspended. \n    *Process structuring information: process's children id's, or the id's of other processes related to the current one in some functional way.\n    Process State: State may enter into new, ready, running, waiting, dead depending on CPU scheduling.\n    Process Number (PID): A unique identification number for each process in the operating system (also known as Process ID).\n    Program Counter (PC): A pointer to the address of the next instruction to be executed for this process.\n    CPU Registers: Indicates various register set of CPU where process need to be stored for execution for running state.\n    CPU Scheduling Information: indicates the information of a process with which it uses the CPU time through scheduling.\n    Memory Management Information: includes the information of page table, memory limits, Segment table depending on memory used by the operating system.\n    I/O Status Information: Includes a list of I/O devices allocated to the process.\n\t","title":"Process Control Block"},{"date":"2018-09-30","link":"https://en.wikipedia.org/wiki/Memory-mapped_I/O","text":"Memory-mapped I/O (MMIO) and port-mapped I/O (PMIO) are two complementary methods of performing input/output (I/O between the central processing unit (CPU) and peripheral devices in a computer.","title":"Memory-mapped I/O"},{"date":"2018-09-30","link":"","text":"Kindle\n---------------------\n|000|140|340|000|000|\n---------------------\n|   |   | x |   |   |\n---------------------\n\nBubble Sort - swap 2\nSelection Sort - select the minimum\nInsertion Sort - select pivot and insert at right position\nMergeSort - divide and sort two small arrays","title":"Data Structures and Algorithms in Java"},{"date":"2018-10-01","link":"https://en.wikipedia.org/wiki/Instruction_set_architecture","text":"ISA serves as the interface between software and hardware.\n\n","title":"ISA"},{"date":"2018-10-01","link":"https://en.wikipedia.org/wiki/Direct_memory_access","text":"Direct memory access (DMA) is a feature of computer systems that allows certain hardware subsystems to access main system memory (Random-access memory), independent of the central processing unit (CPU).\n\nThe DMA chip can be used to move large blocks of data between two memory locations, or it can be used to move blocks of data from a peripheral device to memory. ","title":"DMA"},{"date":"2018-10-01","link":"https://en.wikipedia.org/wiki/Conventional_PCI","text":"Conventional PCI is a local computer bus for attaching hardware devices in a computer. PCI is the initialism for Peripheral Component Interconnect.\n\nDevices connected to the PCI bus appear to a bus master to be connected directly to its own bus and are assigned addresses in the processor's address space.\n\nLEARN MORE","title":"Conventional PCI"},{"date":"2018-10-01","link":"https://docs.google.com/spreadsheets/d/1wijIFVnnrdvsv1_Kw6n1O_kqLEYYtPk-lEbFJfoI3fU/edit#gid=0&range=A66:C66","text":"Propagation Delay: The time it takes a single bit to travel over a link at propagation speed.\nPacketization Delay: the time from when the first to the last bit of a packet is transmited.","title":"Computer Networks II"},{"date":"2018-10-01","link":"","text":"Mutexes are generally implemented with atomic operations on a single memory value. For instance, a lock can be a single word that is free when 0 and locked when 1. To acquire the lock, the processor will lock the memory bus (so no other processors can read or write to memory), read the most-current value of the word, set it to 1 if it is 0, and unlock the memory bus. To unlock, the word can be set to 0.\n\nTest-and-set instruction: is an instruction used to write 1 (set) to a memory location and return its old value as a single atomic (i.e., non-interruptible) operation.\nhttps://en.wikipedia.org/wiki/Test-and-set\n\nFetch-and-add instruction: atomically increments the contents of a memory location by a specified value and returns the old value.\nhttps://en.wikipedia.org/wiki/Fetch-and-add\n\nCompare-and-swap instruction: atomically compares the contents of a memory location with a given value and, only if they are the same, modifies the contents of that memory location to a new given value and returns 1 if successful.\nhttps://en.wikipedia.org/wiki/Compare-and-swap","title":"Locks"},{"date":"2018-10-01","link":"","text":"PDF\n---------------------\n|000|149|191|000|000|\n---------------------\n|   |   | x |   |   |\n---------------------\n\nIn Java, one type is a subtype of another if they are related by an extends or implements clause.\n\nThe Get and Put Principle: use an extends wildcard when you only get values out of a structure, use a super wildcard when you only put values into a structure, and don't use a wildcard when you both get and put.\n\n-Set is a collection of items that cannot contain duplicates.\n-LinkedHashSet guarantees that its iterators will return their elements in the order in which they were first added.\n-SortedSet and NavigableSet guarantees that its iterator will traverse the set in ascending element order","title":"Java Generics and Collections"},{"date":"2018-10-02","link":"https://en.wikipedia.org/wiki/Linker_(computing)","text":"A linker or link editor is a computer utility program that takes one or more object files generated by a compiler and combines them into a single executable file, library file, or another 'object' file.\n\nDynamic Linking:\nAdvantages:\n- Often-used libraries need to be stored in only one location, not duplicated in every single executable file.\n- If a bug in a library function is corrected by replacing the library, all programs using it dynamically will benefit from the correction after restarting them. Programs that included this function by static linking would have to be re-linked first.\n\nDynamic Linking x Static Linking","title":"Linker"},{"date":"2018-10-02","link":"https://docs.google.com/spreadsheets/d/1wijIFVnnrdvsv1_Kw6n1O_kqLEYYtPk-lEbFJfoI3fU/edit#gid=0&range=A66:C66","text":" ","title":"Computer Networks I"},{"date":"2018-10-03","link":"https://en.wikipedia.org/wiki/Read-only_memory","text":"Read-only memory (ROM) is a type of non-volatile memory used in computers and other electronic devices. Data stored in ROM can only be modified slowly, with difficulty, or not at all, so it is mainly used to store firmware (software that is closely tied to specific hardware, and unlikely to need frequent updates) or application software in plug-in cartridges.\n\nProgrammable read-only memory (PROM), or one-time programmable ROM (OTP), can be written to or programmed via a special device called a PROM programmer.\n\nErasable programmable read-only memory (EPROM) can be erased by exposure to strong ultraviolet light (typically for 10 minutes or longer), then rewritten with a process that again needs higher than usual voltage applied.","title":"ROM"},{"date":"2018-10-03","link":"","text":"PDF\n\nFor each method:\n- Purpose: Why does this method exist?\n- Requirements (pre-conditions): What inputs do we need, and what state must the object be in, for this method to work?\n- Promises (post-conditions): What state is the object in, and what values are returned, on successful completion of this method?\n- Exceptions: What can go wrong, and what exceptions may be thrown?","title":"Practices of an Agiler Developer"},{"date":"2018-10-03","link":"https://en.wikipedia.org/wiki/Power-on_self-test","text":"Power-on self-test (POST) is a process performed by firmware or software routines immediately after a computer or other digital electronic device is powered on.\n\nThe results of the POST may be displayed on a panel that is part of the device, output to an external device, or stored for future retrieval by a diagnostic tool. Since a self-test might detect that the system's usual human-readable display is non-functional, an indicator lamp or a speaker may be provided to show error codes as a sequence of flashes or beeps. \n\nIn the case of a computer, the POST routines are part of a device's pre-boot sequence; if they complete successfully, the bootstrap loader code is invoked to load an operating system.\n\nThe principal duties of the main BIOS during POST are as follows:\n    verify CPU registers\n    verify the integrity of the BIOS code itself\n    verify some basic components like DMA, timer, interrupt controller\n    find, size, and verify system main memory\n    initialize BIOS\n    pass control to other specialized extension BIOSes (if installed)\n    identify, organize, and select which devices are available for booting\n\nThe BIOS begins its POST when the CPU is reset. The first memory location the CPU tries to execute is known as the reset vector.","title":"Power-on self-test"},{"date":"2018-10-03","link":"https://en.wikipedia.org/wiki/Instruction_cycle","text":"-Program counter (PC)\n    Counter that keeps track of the memory address of the instruction that is to be executed next.\n-Memory address register (MAR)\n    Holds the address of a block of memory for reading from or writing to.\n-Memory data register (MDR)\n    A two-way register that holds data fetched from memory (and ready for the CPU to process) or data waiting to be stored in memory\n-Instruction register (IR)\n    A temporary holding ground for the instruction that has just been fetched from memory.\n-Control unit (CU)\n    Decodes the program instruction in the IR, selecting machine resources, such as a data source register and a particular arithmetic operation, and coordinates activation of those resources.\n-Arithmetic logic unit (ALU)\n    Performs mathematical and logical operations.\n-Floating-point unit (FPU)\n    Performs floating-point operations.\n\n1- Fetch the instruction: The next instruction is fetched from the memory address that is currently stored in the program counter and stored into the instruction register.\n2- Decode the instruction: During this cycle the encoded instruction present in the instruction register is interpreted by the decoder.\n3- Read the effective address: In the case of a memory instruction (direct or indirect) the execution phase will be during the next clock pulse. If the instruction has an indirect address, the effective address is read from main memory, and any required data is fetched from main memory to be processed and then placed into data registers.\n4- Execute the instruction: The control unit of the CPU passes the decoded information as a sequence of control signals to the relevant function units of the CPU to perform the actions required by the instruction such as reading values from registers, passing them to the ALU to perform mathematical or logic functions on them, and writing the result back to a register. If the ALU is involved, it sends a condition signal back to the CU. The result generated by the operation is stored in the main memory or sent to an output device. Based on the feedback from the ALU, the PC may be updated to a different address from which the next instruction will be fetched.\n\nFetch Instruction:\n\tThe CPU sends the contents of the PC to the MAR and sends a read command on the address bus\n\tIn response to the read command (with address equal to PC), the memory returns the data stored at the memory location indicated by PC on the data bus\n\tThe CPU copies the data from the data bus into its MDR.\n\tThe CPU copies the data from the MDR to the instruction register for instruction decoding\n\tThe PC is incremented so that it points to the next instruction. This step prepares the CPU for the next cycle.","title":"Instruction Cycle"},{"date":"2018-10-06","link":"https://en.wikipedia.org/wiki/Programmed_input/output","text":"Programmed input/output (PIO) is a method of transferring data between the CPU and a peripheral, such as a network adapter or an ATA storage device.\n\n","title":"Programmed input/output"},{"date":"2018-10-06","link":"https://en.wikipedia.org/wiki/Southbridge_(computing)","text":"A southbridge chipset handles all of a computer's I/O functions, such as USB, audio, serial, the system BIOS, the ISA bus, the interrupt controller and the IDE channels.","title":"Southbridge"},{"date":"2018-10-06","link":"https://en.wikipedia.org/wiki/Northbridge_(computing)","text":"The northbridge typically handles communications among the CPU, in some cases RAM, and PCI Express (or AGP) video cards, and the southbridge.","title":"Northbridge"},{"date":"2018-10-06","link":"https://docs.google.com/spreadsheets/d/1wijIFVnnrdvsv1_Kw6n1O_kqLEYYtPk-lEbFJfoI3fU/edit?usp=sharing","text":" ","title":"Computer Systems III"},{"date":"2018-10-08","link":"","text":"Focus your learning on three areas, in the following order of priority:\n1- Always focus on improving fundamentals above all else.\n2- There's a stack of technologies that you probably use every day. When new versions of these tools are released, it's worth investing the time to learn about them.\n3- In-demand tech that is backed by market leaders.\n\nUse test-driven development. Write the test first, then write the code that satisfies the test.\nUse an iterative design approach. Don't spend time trying to make code perfect before you've spent time trying to make the code work.\n\nIn the beginning, your boss or client won't be thrilled by your resistance, but once you demonstrate that you are trustworthy and reliable, everything will start to change.\n\nNot all time spent \"improving\" code has the same ROI.","title":"Become a better Developer"},{"date":"2018-10-11","link":"","text":"PDF\n-------------\n|010|037|153|\n-------------\n| x |   |   |\n-------------","title":"Java Concurrency in Practice"}]
